<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Claim Status Report Tool - Spreadsheet Simplicity</title>
    
    <!-- The Tailwind CSS CDN is used for simplicity in this single-file tool. For public production websites, a build step is recommended. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        #loader { display: none; border: 5px solid #f3                    } else {
                        indices[`${key}Index`] = colLetterToIndex(config.columns[key]);
                    }
                }
                
                if (Object.values(indices).some(val => val === -1 || (Array.isArray(val) && val.includes(-1)))) {
                    throw new Error("Invalid column letter found in configuration.");
                }
                config.indices = indices;
                return config;
            } catch (error) {
                displayStatus(`Configuration Error: ${error.message}`, 'error');
                return null;
            }
        }
        
        // --- STEP 1: Process & Triage Files ---
        async function processAndTriageFiles(mainFile, yesterdayFile, config) {
            resetUI();
            displayStatus('Processing... Please wait.', 'info', true);
            document.getElementById('process-btn-container').classList.add('hidden'); 

            const { indices } = config;
            const hasYesterdayReport = !!yesterdayFile;

            const readFileAsAOA = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array', cellDates: true });
                        resolve(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { header: 1, defval: null }));
                    } catch (err) { reject(new Error(`Failed to read ${file.name}: ${err.message}`)); }
                };
                reader.onerror = () => reject(new Error(`File reader error on ${file.name}`));
                reader.readAsArrayBuffer(file);
            });

            try {
                const main_aoa = await readFileAsAOA(mainFile);
                if (main_aoa.length < 1) throw new Error("Main report is empty.");
                processedReportData = { today: getStatsForAOA(main_aoa, config), yesterday: null }; 
                
                if (hasYesterdayReport) {
                    const yesterday_aoa = await readFileAsAOA(yesterdayFile);
                    processedReportData.yesterday = getStatsForAOA(yesterday_aoa, config);
                    const yesterdayDataMap = new Map();
                    yesterday_aoa.slice(1).forEach(row => {
                        const claimNumber = row[indices.claimNumberIndex];
                        if (claimNumber != null) {
                            yesterdayDataMap.set(String(claimNumber).trim(), {
                                state: String(row[indices.claimStatusIndex] || '').trim().toUpperCase(),
                                type: String(row[indices.claimTypeIndex] || '').trim().toUpperCase(),
                                charges: parseCurrency(row[indices.totalChargesIndex])
                            });
                        }
                    });
                    config.yesterdayDataMap = yesterdayDataMap;
                }
                
                reportHeader = [...main_aoa[0]];
                
                let daysInsert = indices.cleanAgeIndex + 1;
                let notes = indices.notesIndex;

                if (hasYesterdayReport) {
                    reportHeader.splice(indices.claimStatusIndex, 0, 'Yest. Claim State');
                    if (indices.claimStatusIndex <= daysInsert) daysInsert++;
                    if (indices.claimStatusIndex <= notes) notes++;
                }
                reportHeader.splice(daysInsert, 0, 'Days Bucket');
                if (daysInsert <= notes) notes++;
                reportHeader.push('Added (Owner)', 'Due Date');
                
                finalColumnIndices = { daysInsert, notes };

                for (const originalRow of main_aoa.slice(1)) {
                    if (originalRow.every(cell => cell === null)) continue;
                    
                    const claimState = String(originalRow[indices.claimStatusIndex] || '').trim().toUpperCase();
                    const newRow = createEnhancedRow(originalRow, config, finalColumnIndices.daysInsert);

                    if (claimState.includes('PREBATCH')) {
                        triagedPrebatchRows.push(newRow);
                    } else if (claimState.includes('MANAGEMENT') && claimState.includes('REVIEW')) {
                        triagedMgmtReviewRows.push(newRow);
                    } else {
                        triagedMainReportRows.push(newRow);
                    }
                }
                
                displayStatus('', 'info', false); 
                if (triagedMgmtReviewRows.length > 0) {
                    displayAssignmentTable(triagedMgmtReviewRows, finalColumnIndices.notes);
                } else {
                    finalizeAndGenerateReports();
                }

            } catch (error) {
                displayStatus(`Error: ${error.message}`, 'error');
                console.error(error);
                document.getElementById('process-btn-container').classList.remove('hidden');
            }
        }

        // --- STEP 2: Finalize Assignments & Generate All Reports ---
        function finalizeAndGenerateReports() {
            displayStatus('Generating all reports...', 'info', true);
            document.getElementById('mgmt-review-assignment-container').classList.add('hidden');

            if (triagedMgmtReviewRows.length > 0) {
                const inputs = document.querySelectorAll('#assignment-table-body input');
                const noteToAssignmentMap = new Map();
                inputs.forEach(input => {
                    if (input.value.trim()) {
                        noteToAssignmentMap.set(input.dataset.note, input.value.trim());
                    }
                });

                triagedMgmtReviewRows.forEach(row => {
                    const noteText = String(row[finalColumnIndices.notes] || '').trim();
                    const assignment = noteToAssignmentMap.get(noteText);
                    if (assignment) {
                        row[row.length - 2] = assignment;
                    }
                });
            }

            if (triagedPrebatchRows.length > 0) {
                generatePrebatchReport();
            }

            if (triagedMgmtReviewRows.length > 0) {
                generateTeamMgmtReviewReport();
            }

            const allActionableRows = [...triagedMainReportRows, ...triagedMgmtReviewRows];
            if (allActionableRows.length > 0) {
                generateMainActionReport(allActionableRows);
            }
            
            if (document.getElementById('download-links').children.length > 0) {
                displayStatus('All reports generated!', 'success');
                const copyBtnContainer = document.getElementById('copy-email-container');
                copyBtnContainer.innerHTML = `<button id="copyEmailBtn" class="inline-block bg-blue-600 text-white font-bold text-lg rounded-lg py-3 px-10 hover:bg-blue-700">Copy Email Text</button>`;
                copyBtnContainer.addEventListener('click', (e) => {
                    if(e.target.id === 'copyEmailBtn') copyEmailText();
                });
            } else {
                displayStatus('No data to generate reports.', 'info');
            }
        }
        
        // --- Reusable Workbook Builder ---
        function buildPrioritizedWorkbook(rowsToProcess, header, config, reportTitle, coverPageDescription) {
            const { indices, rules } = config;
            const highDollarSheetName = `High Dollar - ${rules.owners.highDollar}`;
            const masterSheetName = "All Data";
            const sheetsData = { [masterSheetName]: [header], [highDollarSheetName]: [header] };
            const tabMetadata = {};
            const overallSummary = {
                par: { '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0, total: 0 },
                nonpar: { '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0, total: 0 }
            };

            for (const newRow of rowsToProcess) {
                const cleanAge = parseInt(newRow[indices.cleanAgeIndex], 10);
                const networkStatusRaw = String(newRow[indices.networkStatusIndex] || '').toUpperCase();
                const networkType = networkStatusRaw.includes('OUT') ? 'nonpar' : 'par';
                const claimState = String(newRow[indices.claimStatusIndex] || '').trim().toUpperCase();
                const isMgmtReviewState = claimState.includes('MANAGEMENT') && claimState.includes('REVIEW');
                
                overallSummary[networkType].total++;
                if (!isNaN(cleanAge)) {
                    if (cleanAge >= 28 && cleanAge <= 29) { overallSummary[networkType]['28-29']++; }
                    else if (cleanAge >= 21 && cleanAge <= 27) { overallSummary[networkType]['21-27']++; }
                    else if (cleanAge >= 30) { overallSummary[networkType]['30+']++; }
                    else { overallSummary[networkType]['0-20']++; }
                }

                const owner = newRow[newRow.length - 2];
                const totalCharges = parseCurrency(newRow[indices.totalChargesIndex]);
                const claimType = String(newRow[indices.claimTypeIndex] || '').trim().toUpperCase();
                const isHighCost = !isNaN(totalCharges) && ((claimType.includes('PROFESSIONAL') && totalCharges > rules.highDollar.professional) || (claimType.includes('INSTITUTIONAL') && totalCharges > rules.highDollar.institutional));

                if (isHighCost && isMgmtReviewState) {
                    sheetsData[highDollarSheetName].push(newRow);
                } else {
                    const dsnpRaw = String(newRow[indices.dsnpIndex] || '').toUpperCase();
                    let dsnpStatus = dsnpRaw.includes('NON DSNP') ? 'NonDSNP' : (dsnpRaw.includes('DSNP') || dsnpRaw === 'Y' ? 'DSNP' : '');

                    let statusTab = claimState;
                    if(isMgmtReviewState) statusTab = 'MgmtRev';
                    
                    const tabOwner = owner; 

                    if (dsnpStatus && tabOwner && networkType) {
                        let tabKey = '', priorityLevel = 0, priorityLabel = '';
                        
                        if (cleanAge >= 28 && cleanAge <= 29) { priorityLevel = 1; priorityLabel = "CRITICAL (28-29d)"; }
                        else if (cleanAge >= 21 && cleanAge <= 27) { priorityLevel = 2; priorityLabel = "PRIORITY (21-27d)"; }
                        else if (cleanAge >= 30) { priorityLevel = 3; priorityLabel = "Backlog (30+d)"; }
                        else { priorityLevel = 4; priorityLabel = "Queue (0-20d)"; }

                        tabKey = truncateSheetName(`${priorityLabel} ${networkType === 'par' ? 'Par' : 'NonPar'} ${statusTab} ${dsnpStatus}`);
                        
                        if (!sheetsData[tabKey]) {
                            sheetsData[tabKey] = [header];
                            tabMetadata[tabKey] = { owner: tabOwner, priority: priorityLevel };
                        }
                        sheetsData[tabKey].push(newRow);
                    }
                }
                
                const noteText = String(newRow[finalColumnIndices.notes] || '');
                if (indices.notesIndex >= 0 && noteText.toLowerCase().includes('w9')) {
                    let w9SheetName = '', tabOwner = '', priorityLevel = 5;
                    const noteLower = noteText.toLowerCase();
                    if (noteLower.includes('requested') || noteLower.includes('req') || noteLower.includes('due')) { w9SheetName = 'W9 Follow-Up'; tabOwner = rules.w9Owners.followUp; }
                    else if (noteLower.includes('denied') || noteLower.includes('missing') || noteLower.includes('not on file') || noteLower.includes('not received')) { w9SheetName = 'W9 Letter Needed'; tabOwner = rules.w9Owners.letterNeeded; }
                    else if (noteLower.includes('received') || noteLower.includes('reprocess') || noteLower.includes('rerun')) { w9SheetName = 'W9 Received - Reprocess'; tabOwner = rules.w9Owners.reprocess; }
                    
                    if (w9SheetName) {
                        if (!sheetsData[w9SheetName]) { sheetsData[w9SheetName] = [header]; tabMetadata[w9SheetName] = { owner: tabOwner, priority: priorityLevel }; }
                        sheetsData[w9SheetName].push(newRow);
                    }
                }
                sheetsData[masterSheetName].push(newRow);
            }

            const coverPageData = [
                [reportTitle], [`Client: ${config.clientName}`], [`Date: ${getFormattedDate()}`], [], 
                [coverPageDescription],
                ["Category", "28-29 Days (Critical)", "21-27 Days (Priority)", "30+ Days (Backlog)", "0-20 Days (Queue)", "Total Active Claims"],
                ["Par Claims", overallSummary.par['28-29'], overallSummary.par['21-27'], overallSummary.par['30+'], overallSummary.par['0-20'], overallSummary.par.total],
                ["Non-Par Claims", overallSummary.nonpar['28-29'], overallSummary.nonpar['21-27'], overallSummary.nonpar['30+'], overallSummary.nonpar['0-20'], overallSummary.nonpar.total],
                [],
                ["Core Strategy:", "This report is built to achieve the 95% compliance target by focusing on claims nearing the 30-day threshold. The primary emphasis is on PAR claims, while NON-PAR claims should be monitored. Work the tabs in the order of priority listed below."],
                [],
            ];

            const addSectionToCover = (title, description, priority, allTabs) => {
                const filteredTabs = allTabs.filter(key => tabMetadata[key] && tabMetadata[key].priority === priority).sort();
                if (filteredTabs.length > 0) {
                    coverPageData.push([title], [description], ["Tab Name", "Claim Count", "Assigned Owner"]);
                    filteredTabs.forEach(key => coverPageData.push([key, sheetsData[key].length - 1, tabMetadata[key].owner]));
                    coverPageData.push([]);
                }
            };
            
            const allBreakoutTabs = Object.keys(tabMetadata);
            addSectionToCover( "Priority 1: CRITICAL (28-29 days)", "WORK THESE FIRST. These claims will breach the 30-day threshold immediately. Clearing them is the top priority to prevent failures.", 1, allBreakoutTabs );
            addSectionToCover( "Priority 2: PRIORITY (21-27 days)", "WORK THESE SECOND. This is the main focus for proactively reducing the aging pool and improving the KPI percentage.", 2, allBreakoutTabs );
            addSectionToCover( "Priority 3: Backlog (30+ days)", "WORK THESE THIRD. Chip away at this backlog by addressing a small, limited number of claims daily, especially in response to urgent provider requests.", 3, allBreakoutTabs );
            addSectionToCover( "Priority 4: Standard Queue (0-20 days)", "WORK THESE LAST. After addressing the higher priorities, work through this queue of new claims to stay ahead.", 4, allBreakoutTabs );
            addSectionToCover( "W9 and Other Tasks", "These tabs group claims that require specific, non-aging-related actions. Handle as needed.", 5, allBreakoutTabs );

            const coverWS = XLSX.utils.aoa_to_sheet(coverPageData);
            coverWS['!cols'] = [{ wch: 25 }, { wch: 20 }, { wch: 22 }, { wch: 20 }, { wch: 20 }, { wch: 20 }];
            
            const newWorkbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(newWorkbook, coverWS, "Cover Page");
            
            const sortedBreakoutTabs = Object.keys(sheetsData).filter(n => ![masterSheetName, highDollarSheetName].includes(n)).sort((a, b) => {
                const prioA = (tabMetadata[a] ? tabMetadata[a].priority : 99) || 99; const prioB = (tabMetadata[b] ? tabMetadata[b].priority : 99) || 99;
                return prioA !== prioB ? prioA - prioB : a.localeCompare(b);
            });
            
            const sheetOrder = ["Cover Page", highDollarSheetName, ...sortedBreakoutTabs, masterSheetName];
            sheetOrder.forEach(sheetName => {
                if (sheetName !== "Cover Page" && sheetsData[sheetName] && sheetsData[sheetName].length > 1) { 
                    const ws = XLSX.utils.aoa_to_sheet(sheetsData[sheetName]);
                    ws['!autofilter'] = { ref: XLSX.utils.encode_range(XLSX.utils.decode_range(ws['!ref'])) };
                    XLSX.utils.book_append_sheet(newWorkbook, ws, sheetName);
                }
            });
            
            return newWorkbook;
        }

        // --- Report Generation Wrappers ---
        function generatePrebatchReport() {
            const fileName = `${currentConfig.clientName} Prebatch Report for ${getFormattedDate()}.xlsx`;
            const sheetName = 'Prebatch Claims';
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([reportHeader, ...triagedPrebatchRows]);
            ws['!autofilter'] = { ref: XLSX.utils.encode_range(XLSX.utils.decode_range(ws['!ref'])) };
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
            const fileData = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            createDownloadLink(fileData, fileName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'Prebatch Report');
        }

        function generateMainActionReport(allActionableRows) {
            const workbook = buildPrioritizedWorkbook(allActionableRows, reportHeader, currentConfig, "Daily Action Report (Management)", "Overall Claim Summary (Excludes Prebatch)");
            const fileName = `${currentConfig.clientName} Daily Action Report for ${getFormattedDate()}.xlsx`;
            const fileData = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            createDownloadLink(fileData, fileName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'Action Report (Mgmt)');
        }

        function generateTeamMgmtReviewReport() {
            const workbook = buildPrioritizedWorkbook(triagedMgmtReviewRows, reportHeader, currentConfig, "Management Review Action Report (Teams)", "Management Review Claim Summary");
            const fileName = `${currentConfig.clientName} Mgmt Review Action Report for ${getFormattedDate()}.xlsx`;
            const fileData = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            createDownloadLink(fileData, fileName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'Mgmt Review Report (Teams)');
        }

        // --- Helper & UI Functions ---
        function createEnhancedRow(originalRow, config, daysInsertIndex) {
            const { indices, rules, yesterdayDataMap } = config;
            const newRow = [...originalRow];

            if (yesterdayDataMap) {
                const claimNumber = String(originalRow[indices.claimNumberIndex] || '').trim();
                const yestData = yesterdayDataMap.get(claimNumber);
                let yestStateForColumn = 'NEW';
                if (yestData) {
                    yestStateForColumn = yestData.state;
                    const isYestMgmtReview = yestData.state.includes('MANAGEMENT') && yestData.state.includes('REVIEW');
                    if (isYestMgmtReview && !isNaN(yestData.charges) && ((yestData.type.includes('PROFESSIONAL') && yestData.charges > rules.highDollar.professional) || (yestData.type.includes('INSTITUTIONAL') && yestData.charges > rules.highDollar.institutional))) {
                        yestStateForColumn = 'HC MGMT REV';
                    }
                }
                newRow.splice(indices.claimStatusIndex, 0, yestStateForColumn);
            }

            const cleanAge = parseInt(originalRow[indices.cleanAgeIndex], 10);
            let daysValue = '';
            if (!isNaN(cleanAge)) {
                if (cleanAge >= 28 && cleanAge <= 29) { daysValue = '28-29 days'; }
                else if (cleanAge >= 21 && cleanAge <= 27) { daysValue = '21-27 days'; }
                else if (cleanAge >= 30) { daysValue = '30+ days'; }
                else { daysValue = '0-20 days'; }
            }
            newRow.splice(daysInsertIndex, 0, daysValue);

            const claimState = String(originalRow[indices.claimStatusIndex] || '').trim().toUpperCase();
            const claimType = String(originalRow[indices.claimTypeIndex] || '').trim().toUpperCase();
            const totalCharges = parseCurrency(originalRow[indices.totalChargesIndex]);
            const isMgmtReviewState = claimState.includes('MANAGEMENT') && claimState.includes('REVIEW');
            const isHighCost = isMgmtReviewState && !isNaN(totalCharges) && ((claimType.includes('PROFESSIONAL') && totalCharges > rules.highDollar.professional) || (claimType.includes('INSTITUTIONAL') && totalCharges > rules.highDollar.institutional));

            let ownerValue = '';
            if (isHighCost && isMgmtReviewState) { ownerValue = rules.owners.highDollar; } 
            else if (isMgmtReviewState) { ownerValue = rules.owners.mgmtReview; }
            else if (claimState === 'ONHOLD') { ownerValue = rules.owners.onHold; }
            else if (claimState === 'PEND') { ownerValue = rules.owners.pend; } 
            else if (claimState === 'DENY') { ownerValue = rules.owners.deny; } 
            else if (claimState === 'PR') { ownerValue = originalRow[indices.payerIndex] || ''; }
            
            const noteText = String(originalRow[indices.notesIndex] || '');
            newRow.push(ownerValue, extractDueDateFromNote(noteText));
            return newRow;
        }
        
        function autoAssignOwner(noteText) {
            const lowerNote = noteText.toLowerCase();
            if (lowerNote.includes('claim paid as per') || lowerNote.includes('hold for review per rachael')) { return 'Client/Claims'; }
            if (lowerNote.includes('no matching contract found') || lowerNote.includes('pay to name mismatch') || lowerNote.includes('issue while getting contract') || lowerNote.includes('hold for payer review') || lowerNote.includes('provider type not found') || lowerNote.includes('no data for the rendering provider') || lowerNote.includes('missing contract requested')) { return 'PV'; }
            const claimsKeywords = [ 'to be priced at line level', 'to be priced at claim level', 'duplicate service', 'duplicate validation', 'ambulance duplicate validation', 'w9 req', 'w9 requested', 'w9 past due', 'w9 on file', 'w9 recvd', 'payment>', 'exceeds total payment', 'net pay >', '$10,000', '$10000', 'pv updated', 'rerun', 'remap', 'pay-to-provider id updated', 'provider not found', 'precertification/authorization', 'contract rate already updated', 'validated/adjudicated', 'oon rate applied', 'see clients notes below', 'servicelineseq', 'eye exam', 'claim allowed amount' ];
            if (claimsKeywords.some(keyword => lowerNote.includes(keyword))) { return 'Claims'; }
            return '';
        }

        function displayAssignmentTable(mgmtRows, notesIndex) {
            const tableBody = document.getElementById('assignment-table-body');
            tableBody.innerHTML = '';
            const notesSummary = new Map();
            mgmtRows.forEach(row => {
                const noteText = String(row[notesIndex] || '').trim();
                if (noteText === '') return;
                if (!notesSummary.has(noteText)) { notesSummary.set(noteText, { count: 0 }); }
                notesSummary.get(noteText).count++;
            });
            const sortedNotes = [...notesSummary.entries()].sort((a, b) => b[1].count - a[1].count);
            sortedNotes.forEach(([noteText, data]) => {
                const preAssigned = autoAssignOwner(noteText);
                const row = document.createElement('tr');
                row.innerHTML = `<td class="px-6 py-4 text-sm text-gray-700 align-top break-words max-w-lg">${noteText}</td><td class="px-6 py-4 text-sm text-gray-700 align-top">${data.count}</td><td class="px-6 py-4 text-sm text-gray-700 align-top"><input type="text" class="table-input" data-note="${noteText.replace(/"/g, '&quot;')}" value="${preAssigned}"></td>`;
                tableBody.appendChild(row);
            });
            document.getElementById('mgmt-review-assignment-container').classList.remove('hidden');
        }

        function resetUI() {
            displayStatus('', 'info', false);
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('mgmt-review-assignment-container').classList.add('hidden');
            document.getElementById('download-links').innerHTML = '';
            document.getElementById('copy-email-container').innerHTML = '';
            document.getElementById('process-btn-container').classList.remove('hidden');
            triagedPrebatchRows = []; triagedMainReportRows = []; triagedMgmtReviewRows = [];
            reportHeader = []; finalColumnIndices = {};
        }

        function createDownloadLink(data, fileName, mimeType, label) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.className = 'inline-block bg-green-600 text-white font-bold text-lg rounded-lg py-3 px-10 hover:bg-green-700 mb-2 md:mb-0';
            link.textContent = `Download ${label}`;
            document.getElementById('download-links').appendChild(link);
        }

        function displayStatus(message, type, showLoader = false) {
            document.getElementById('results-container').classList.remove('hidden');
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.style.color = type === 'error' ? 'red' : (type === 'success' ? 'green' : '#4f46e5');
            document.getElementById('loader').style.display = showLoader ? 'block' : 'none';
        }

        function getStatsForAOA(aoa, cfg) {
            const { indices: idx, rules: rls } = cfg;
            const dayBuckets = { '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0 };
            const stats = { 'PEND': { total: 0, ...dayBuckets }, 'ONHOLD': { total: 0, ...dayBuckets }, 'MANAGEMENTREVIEW': { total: 0, ...dayBuckets }, 'HC MGMT REV': { total: 0, ...dayBuckets }, 'W9_LETTER_NEEDED': { total: 0, ...dayBuckets }, 'W9_FOLLOW_UP': { total: 0, ...dayBuckets } };
            for(const row of aoa.slice(1)) {
                if (row.every(cell => cell === null)) continue;
                let claimState = String(row[idx.claimStatusIndex] || '').trim().toUpperCase();
                if (claimState.includes('PREBATCH')) continue;
                const totalCharges = parseCurrency(row[idx.totalChargesIndex]);
                const claimType = String(row[idx.claimTypeIndex] || '').trim().toUpperCase();
                const cleanAge = parseInt(row[idx.cleanAgeIndex], 10);
                let daysValue = !isNaN(cleanAge) ? (cleanAge >= 28 && cleanAge <= 29 ? '28-29' : (cleanAge >= 21 && cleanAge <= 27 ? '21-27' : (cleanAge >= 30 ? '30+' : '0-20'))) : '';
                let finalClaimState = claimState;
                const isMgmtReview = claimState.includes('MANAGEMENT') && claimState.includes('REVIEW');
                if (isMgmtReview && !isNaN(totalCharges) && ((claimType.includes('PROFESSIONAL') && totalCharges > rls.highDollar.professional) || (claimType.includes('INSTITUTIONAL') && totalCharges > rls.highDollar.institutional))) { finalClaimState = 'HC MGMT REV'; }
                if (stats[finalClaimState]) {
                    stats[finalClaimState].total++;
                    if (stats[finalClaimState][daysValue] !== undefined) stats[finalClaimState][daysValue]++;
                } else if (isMgmtReview && stats['MANAGEMENTREVIEW']) {
                    stats['MANAGEMENTREVIEW'].total++;
                    if (stats['MANAGEMENTREVIEW'][daysValue] !== undefined) stats['MANAGEMENTREVIEW'][daysValue]++;
                }
                const noteTextLower = String(row[idx.notesIndex] || '').toLowerCase();
                if (noteTextLower.includes('w9')) {
                    if (noteTextLower.includes('requested') || noteTextLower.includes('req') || noteTextLower.includes('due')) {
                       if (stats['W9_FOLLOW_UP'][daysValue] !== undefined) stats['W9_FOLLOW_UP'][daysValue]++;
                       stats['W9_FOLLOW_UP'].total++;
                    } else if (noteTextLower.includes('denied') || noteTextLower.includes('missing') || noteTextLower.includes('not on file') || noteTextLower.includes('not received')) {
                       if (stats['W9_LETTER_NEEDED'][daysValue] !== undefined) stats['W9_LETTER_NEEDED'][daysValue]++;
                       stats['W9_LETTER_NEEDED'].total++;
                    }
                }
            }
            return stats;
        }

        function copyEmailText() {
            if (!processedReportData || !currentConfig) return alert("Please process a report first.");
            const { clientName, ageColumnLabel } = currentConfig;
            const { today, yesterday } = processedReportData;
            let criticalTotal = 0, priorityTotal = 0;
            Object.values(today).forEach(status => {
                criticalTotal += (status['28-29'] || 0);
                priorityTotal += (status['21-27'] || 0);
            });
            const intro = yesterday ? `Attached is today's Daily Action Report for ${clientName}, structured to align with our new KPI improvement strategy. Previous day's counts are in (parenthesis).` : `Attached is today's Daily Action Report for ${clientName}, structured to align with our new KPI improvement strategy.`;
            const executiveSummary = `Today's immediate focus is on the ${criticalTotal} CRITICAL claims (28-29 days) to prevent compliance failures. The main proactive effort will be on the ${priorityTotal} PRIORITY claims (21-27 days).`;
            const strategicReminders = `**Strategic Reminders:**\n- The primary focus remains on **Par claims** to drive the largest impact on the metric, while continuing to monitor Non-Par claims.\n- Please address a limited number of claims from the **Backlog (30+ Days)** tabs daily, prioritizing urgent provider requests.`;
            const formatStatLine = (t, y) => yesterday ? `${t} (${y})` : `${t}`;
            const createStatBlock = (title, todayStats, yestStats) => {
                const y = yesterday && yestStats ? yestStats : { total: 0, '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0 };
                return `Number of total claims ${title}: ${formatStatLine(todayStats.total, y.total)}\nCRITICAL (28-29 Days): ${formatStatLine(todayStats['28-29'], y['28-29'])}\nPRIORITY (21-27 Days): ${formatStatLine(todayStats['21-27'], y['21-27'])}\nBacklog (30+ Days): ${formatStatLine(todayStats['30+'], y['30+'])}\nQueue (0-20 Days): ${formatStatLine(todayStats['0-20'], y['0-20'])}`;
            };
            const combinedMgmtRevToday = { ...today['MANAGEMENTREVIEW'] };
            const hcToday = today['HC MGMT REV'];
            Object.keys(hcToday).forEach(key => { combinedMgmtRevToday[key] = (combinedMgmtRevToday[key] || 0) + hcToday[key]; });
            let combinedMgmtRevYesterday = yesterday ? { ...(yesterday['MANAGEMENTREVIEW'] || { total: 0, '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0 }) } : { total: 0, '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0 };
            if (yesterday) {
                const hcYesterday = yesterday['HC MGMT REV'] || { total: 0, '28-29': 0, '21-27': 0, '30+': 0, '0-20': 0 };
                Object.keys(hcYesterday).forEach(key => { combinedMgmtRevYesterday[key] = (combinedMgmtRevYesterday[key] || 0) + hcYesterday[key]; });
            }
            const mgmtReviewBlock = `Number of total claims Management Review: ${formatStatLine(combinedMgmtRevToday.total, combinedMgmtRevYesterday.total)}\nOf these, High Dollar Claims: ${formatStatLine(today['HC MGMT REV'].total, yesterday?.['HC MGMT REV']?.total ?? 0)}\nCRITICAL (28-29 Days): ${formatStatLine(combinedMgmtRevToday['28-29'], combinedMgmtRevYesterday['28-29'])}\nPRIORITY (21-27 Days): ${formatStatLine(combinedMgmtRevToday['21-27'], combinedMgmtRevYesterday['21-27'])}\nBacklog (30+ Days): ${formatStatLine(combinedMgmtRevToday['30+'], combinedMgmtRevYesterday['30+'])}\nQueue (0-20 Days): ${formatStatLine(combinedMgmtRevToday['0-20'], combinedMgmtRevYesterday['0-20'])}`;
            const emailBody = `Hello Claims and PV Teams,\n\n${intro}\n\n${executiveSummary}\n\nBelow are the detailed highlights from the report:\n\n${createStatBlock('pending', today['PEND'], yesterday?.['PEND'])}\n\n${createStatBlock('On Hold', today['ONHOLD'], yesterday?.['ONHOLD'])}\n\n${mgmtReviewBlock}\n\n${createStatBlock('needing W9 Letter', today['W9_LETTER_NEEDED'], yesterday?.['W9_LETTER_NEEDED'])}\n\n${createStatBlock('for W9 Follow-Up', today['W9_FOLLOW_UP'], yesterday?.['W9_FOLLOW_UP'])}\n\n${strategicReminders}\n\nPlease let me know if you have any questions.\n\nThis ${clientName} report is based on ${ageColumnLabel}.\n`;
            navigator.clipboard.writeText(emailBody).then(() => {
                const btn = document.getElementById('copyEmailBtn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = originalText; }, 2000);
            }).catch(err => alert('Failed to copy text.'));
        }

        const getFormattedDate = () => {
            const d=new Date(), day=d.getDate(), month=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][d.getMonth()], year=d.getFullYear();
            const s = (day%10===1&&day!==11)?'st':((day%10===2&&day!==12)?'nd':((day%10===3&&day!==13)?'rd':'th'));
            return `${day}${s} ${month} ${year}`;
        }
        
        const extractDueDateFromNote = (noteText) => {
            const match = (noteText || '').match(/due\s*(by)?[:\s]*(\d{1,2}[\/-]\d{1,2}(?:[\/-]\d{2,4})?)/i);
            return match ? match[2] : '';
        }
        
        const parseCurrency = (value) => (value === null || value === undefined) ? NaN : parseFloat(String(value).replace(/[^0-9.-]/g, '')) || NaN;
        const truncateSheetName = (name) => name.replace(/[\\\/\?\*\[\]]/g, '').substring(0, 31);
        document.addEventListener('DOMContentLoaded', initializeTool);
    </script>

</body>
</html>
